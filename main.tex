% Use a package to avoid old (La)TeX habits.
\RequirePackage[l2tabu, orthodox]{nag}

% jsarticle: improved version of Japanese article style
% [dvipdfmx]: we use dvipdfmx.
% [uplatex]: we use uplatex.
% [papersize]: tell page size to pdf generator.
% [a4paper]: paper size is A4.
% [10pt]: point size is 10pt.
\documentclass[dvipdfmx,uplatex,papersize,a4paper,10pt]{jsbook}

% This file is UTF-8 encoded.
\usepackage[utf8]{inputenc}
% Use T1 instead of OT1 for European texts.
\usepackage[T1]{fontenc}
% Fix Computer Modern rounding. Use this if you don't want to use Latin Modern.
% \usepackage{fix-cm}
% Use Latin Modern instead of Computer Modern font.
\usepackage{lmodern}

% AMS-related packages
\usepackage{amstext,amsmath,amsthm,amssymb,amsfonts}

% Avoid non-AMS mathematical usage.
\usepackage[all, warning]{onlyamsmath}

% Use otf fonts.
\usepackage{otf}
% Avoid "Font Shape undefined" error for italic Japanese texts.
\DeclareFontShape{JY2}{hmc}{m}{it}{<->ssub*hmc/m/n}{}
\DeclareFontShape{JY2}{hmc}{m}{sl}{<->ssub*hmc/m/n}{}
\DeclareFontShape{JY2}{hmc}{m}{sc}{<->ssub*hmc/m/n}{}
\DeclareFontShape{JY2}{hgt}{m}{it}{<->ssub*hgt/m/n}{}
\DeclareFontShape{JY2}{hgt}{m}{sl}{<->ssub*hgt/m/n}{}
\DeclareFontShape{JY2}{hmc}{bx}{it}{<->ssub*hgt/m/n}{}
\DeclareFontShape{JY2}{hmc}{bx}{sl}{<->ssub*hgt/m/n}{}
\DeclareFontShape{JT2}{hmc}{m}{it}{<->ssub*hmc/m/n}{}
\DeclareFontShape{JT2}{hmc}{m}{sl}{<->ssub*hmc/m/n}{}
\DeclareFontShape{JT2}{hmc}{m}{sc}{<->ssub*hmc/m/n}{}
\DeclareFontShape{JT2}{hgt}{m}{it}{<->ssub*hgt/m/n}{}
\DeclareFontShape{JT2}{hgt}{m}{sl}{<->ssub*hgt/m/n}{}
\DeclareFontShape{JT2}{hmc}{bx}{it}{<->ssub*hgt/m/n}{}
\DeclareFontShape{JT2}{hmc}{bx}{sl}{<->ssub*hgt/m/n}{}

% Use newtx fonts; maybe should be avoided in paper submissions.
\usepackage{newtxtext,newtxmath}

% Scale bigops in math. Not needed if we use newtxmath.
% \usepackage{exscale}

% \braket{}, \set{}
\usepackage{braket}

% Japanese Ruby generation.
\usepackage{pxrubrica}

% Syntax-highlighted program listings.
% jlisting: allow Japanese text in listings.
% \usepackage{listings,jlisting}
\usepackage{listings}

% Pass pagesize to DVI and configure page layout.
% [pass] is used to disable page layout overriding. Remove it if you want to configure page layout through this package.
% [dvipdfm] is for dvipdfmx.
% \usepackage[dvipdfm,pass]{geometry}

% Extended graphics package; provides \includegraphics.
\usepackage{graphicx}

% Extended color package; provides \color.
\usepackage{xcolor}

% Provides \url.
\usepackage{url}

% \mleft/\mright, a little clever replacements for \left/\right.
\usepackage{mleftright}

% \mathscr
\usepackage{mathrsfs}
% Override ursfs.fd to suppress "Font shape `U/rsfs/m/n' in size <5.5>/<10.5> not available" warning.
\DeclareFontFamily{U}{rsfs}{\skewchar\font127}
\DeclareFontShape{U}{rsfs}{m}{n}{%
  % <5> <6> rsfs5
  <5> <5.5> <6> rsfs5
  <7> rsfs7
  % <8> <9> <10> <10.95> <12> <14.4> <17.28> <20.74> <24.88> rsfs10
  <8> <9> <10> <10.5> <10.95> <12> <14.4> <17.28> <20.74> <24.88> rsfs10
}{}

% Part of hyperref.
\usepackage{nameref}

% Turns almost everything into hyper-reference.
\usepackage{hyperref}
% Improves non-ASCII characters in bookmarks.
\usepackage{pxjahyper}

% Float wrapper for algorithms.
\usepackage{algorithm}
% One of algorithm typesetting environments.
\usepackage{algpseudocode}

% Provides \cref, which automatically emits Lemma, Definition, etc.
\usepackage{cleveref}

\theoremstyle{definition}
\newtheorem{definition}{定義}[section]
\newtheorem{example}[definition]{例}
\newtheorem{theorem}[definition]{定理}
\newtheorem{lemma}[definition]{補題}
\newtheorem{corollary}[definition]{系}
\newtheorem{proposition}[definition]{命題}
\newtheorem{axiom}[definition]{公理}
\newtheorem{remark}[definition]{注意}
\newtheorem{exercise}{練習問題}[section]

\crefname{definition}{定義}{定義}
\Crefname{definition}{定義}{定義}
\crefname{example}{例}{例}
\Crefname{example}{例}{例}
\crefname{theorem}{定理}{定理}
\Crefname{theorem}{定理}{定理}
\crefname{lemma}{補題}{補題}
\Crefname{lemma}{補題}{補題}
\crefname{corollary}{系}{系}
\Crefname{corollary}{系}{系}
\crefname{proposition}{命題}{命題}
\Crefname{proposition}{命題}{命題}
\crefname{axiom}{公理}{公理}
\Crefname{axiom}{公理}{公理}
\crefname{remark}{注意}{注意}
\Crefname{remark}{注意}{注意}
\crefname{exercise}{練習問題}{練習問題}
\Crefname{exercise}{練習問題}{練習問題}

% The color scheme is from "hybrid" vim color scheme.
\lstset{%
  numbers=left,
  basicstyle=\small\ttfamily,
  identifierstyle=\color[rgb]{0.372, 0.0, 0.372},
  commentstyle=\color[rgb]{0.372, 0.372, 0.372},
  stringstyle=\color[rgb]{0.0, 0.372, 0.0},
  keywordstyle=\color[rgb]{0.0, 0.372, 0.372}\bfseries,
  backgroundcolor=\color[rgb]{0.894, 0.894, 0.894},
}

\input{common/bnflike-listing.tex}

\title{Rust コンパイラーウォークスルー}
\author{原 将己}
%\date{2017年01月13日}

\begin{document}

\maketitle

\tableofcontents

\chapter{はじめに}



\chapter{Rustコンパイラーの開発フロー}

\section{RFC}

\section{メインリポジトリ}

\section{文書}

\section{フォーラム}


\chapter{RustcとCrateとCargo}

\section{crateのソース}

\section{crateのバイナリー}

\section{Cargoの基本動作}

\section{依存関係の解決}

\section{cratesリポジトリ}



\chapter{字句と構文}

\section{字句解析}

Rustのソースファイルはまず字句解析にかけられます。

\subsection{凡例}

この節ではBNF風の記法を用いて文法を記述しています。BNF風ですが実際にはPEG (解析表現文法) に近い意味論です。

\begin{itemize}
  \item \verb|A B| は連接です。 2つの構文要素をこの順に並べたものです。
  \item \verb$A | B$ はPEGの順序つきOR (\verb|A / B|) です。 \verb|A| を試し、失敗したら \verb|B| を試します。ただし、この節で \verb$A | B$ と書いた場合は、順番による違いが生じないようになっているはずです。
  \item \verb|A*|, \verb|A+|, \verb|A?| は、0回以上の繰り返し、1回以上の繰り返し、高々1回の出現です。いずれも貪欲に実行したものと解釈しますが、それを知らなくても読めるように配慮したつもりです。
  \item \verb|lookahead A| と \verb|not A| は先読み肯定と先読み否定です。慣れていないと読み間違えやすいかもしれません。 \verb|A (not B)| は、 \verb|A| だが \verb|B| が後続しないものです。 \verb|(not B) A| は、 \verb|A| だが同じ場所で \verb|B| にはならないものです。
  \item \verb|eof| は文字列の末尾です。
  \item \verb|"+="| のようにダブルクオートで囲んだものは文字列で、1文字ずつ連接したものと同じです。C言語風のエスケープを使っています。
\end{itemize}

\subsection{Unicode}

Rustの字句解析器はUTF-8でエンコードされたファイルを入力します。UTF-8をデコードしたものは、Unicodeスカラー値の列とみなすことができます。

Unicodeスカラー値とは、 \verb|0| 以上 \verb|0xD800| 未満か \verb|0xE000| 以上 \verb|0x110000| 未満の整数のことです。ここでは、Unicode文字といったらUnicodeスカラー値のことを指すことにします。

\begin{lstlisting}[language=BNFLike, gobble=2]
  AnyChar ::= /* Any Unicode scalar value */

  AnyAsciiChar ::=
    /*Any Unicode scalar value < 128 */
\end{lstlisting}

\subsection{トークン列}

Rustの字句解析器の仕事は、Unicodeスカラー値の列を受け取り、字句エラーがなければトークン列を返すことです。

\begin{lstlisting}[language=BNFLike, gobble=2]
  File ::= MaybeShebang Skip (Token Skip)* eof

  Token ::=
      InnerDocComment
    | OuterDocComment
    | Symbol
    | Literal
    | Identifier
    | StrictKeyword
    | ReservedKeyword
    | Lifetime
\end{lstlisting}

\begin{itemize}
  \item 字句的な特徴からトークンを分類すると、doc-comment, 記号、数値リテラル、文字列系リテラル、識別子とキーワード、生存期間と分けられます。しかし、構文解析器やマクロ展開器にとっての分類は必ずしもこれに沿った形ではありません。
\end{itemize}

\subsection{空白とコメント}

Rustの字句解析器は空白とコメントを無視します。コンパイラにとっては、これらはトークンを明示的に分割する以上の役割はありません。ただし、doc-commentは特別な扱いを受けます。

\begin{lstlisting}[language=BNFLike, gobble=2]
  Skip ::= (Whitespace | Comment)* (not MaySkip)

  Whitespace ::= PatternWhitespace+ (not PatternWhitespace)

  PatternWhitespace ::=
    /* Any Unicode scalar value with PATTERN_WHITE_SPACE */

  Comment ::= "//" (not ("/" | "!")) LineCommentChar* ("\n" | eof)
            | "////" LineCommentChar* ("\n" | eof)
            | "/*" (not ("*" | "!")) BlockCommentBody* "*/"
            | "/**/"

  LineCommentChar ::= (not "\n") AnyChar
  BlockCommentBody ::= (not ("/*" | "*/")) AnyChar
                     | "/*" BlockCommentBody* "*/"

  MaySkip ::= PatternWhitespace
            | "//" (not ("/" | "!"))
            | "////"
            | "/*" (not ("*" | "!"))
            | "/**/"

  MaybeShebang ::= Shebang | not Shebang

  Shebang ::= "#!" (not "[") LineCommentChar* ("\n" | eof)
\end{lstlisting}

\begin{itemize}
  \item UAX~\#31~\cite{UAX31-25} に従い、 \verb|Pattern_White_Space| に分類される文字は全て空白文字とみなされます。 \verb|Pattern_White_Space| はUAX~\#44~\cite{UAX44-18}で規定されており、 \verb|PropList.txt| で取得できます。現時点では以下の文字が \verb|Pattern_White_Space| に分類されます。
    \begin{itemize}
      \item \verb|U+0009| Control: CHARACTER TABULATION
      \item \verb|U+000A| Control: LINE FEED (LF)
      \item \verb|U+000B| Control: LINE TABULATION
      \item \verb|U+000C| Control: FORM FEED (FF)
      \item \verb|U+000D| Control: CARRIAGE RETURN (CR)
      \item \verb|U+0020| SPACE
      \item \verb|U+0085| Control: NEXT LINE (NEL)
      \item \verb|U+200E| LEFT-TO-RIGHT MARK
      \item \verb|U+200F| RIGHT-TO-LEFT MARK
      \item \verb|U+2028| LINE SEPARATOR
      \item \verb|U+2029| PARAGRAPH SEPARATOR
    \end{itemize}
  \item Cと同様に \verb|//| と \verb|/*| がコメントとみなされますが、 doc-commentはトークンとみなされるため、この意味で通常のコメントとは異なります。
  \item Cとは異なり、 \verb|/*| はネストさせることができます。
  \item \verb|////| 型のコメントの中では、doc-commentと同様に、単独でのキャリッジリターンの出現が禁止されています。これはバグではないかと思います。
  \item 1行目が \verb|#!| で始まる場合、その行はシバンとみなされ、コメントと同様に無視されます。ただし、 \verb|#![| で始まる場合は、内部属性と紛らわしいため、例外的にシバンとはみなされません。
\end{itemize}

\subsection{doc-comment}

doc-commentはコメントとよく似た構文を持ちますが、Rustコンパイラはこれを一つのトークンとみなします。

\begin{lstlisting}[language=BNFLike, gobble=2]
  InnerDocComment ::=
      "//!" LineDocCommentChar* ("\r\n" | "\n" | eof)
    | "/*!" BlockDocCommentBody* "*/"

  OuterDocComment ::=
      "///" (not "/") LineDocCommentChar* ("\r\n" | "\n" | eof)
    | "/**" (not "/") BlockDocCommentBody* "*/"

  LineDocCommentChar ::= (not ("\r" | "\n")) AnyChar


  BlockDocCommentBody ::= (not ("\r" | "/*" | "*/")) AnyChar
                        | "\r\n"
                        | "/*" BlockDocCommentBody* "*/"
\end{lstlisting}

\begin{itemize}
  \item \verb|///|, \verb|//!|, \verb|/**|, \verb|/*!| で始まるコメントは、doc-commentと解釈されます。
  \item 例外として、 \verb|////| で始まるコメントと \verb|/**/| は、doc-commentではありません。
  \item これらのdoc-commentは、外部ツールだけではなく、Rustコンパイラによって認識されます。字句的に正しいdoc-commentであっても、構文的に誤った位置にあれば、コンパイルエラーになる可能性があります。
  \item 通常のコメントと異なり、doc-comment内ではキャリッジリターン (CR) が単独で出現してはいけません。必ずラインフィードと対で (CRLF) 出現する必要があります。
  \item Cとは異なり、 \verb|/*| はネストさせることができます。
\end{itemize}

\subsection{記号}

\begin{lstlisting}[language=BNFLike, gobble=2]
  Symbol ::=
      "=" (not ("=" | ">"))
    | "<" (not ("=" | "<" | "-"))
    | "<=" | "==" | "!=" | ">="
    | ">" (not ("=" | ">"))
    | "&&" | "||"
    | "!" (not "=")
    | "~"
    | "+" (not "=")
    | "-" (not ("=" | ">"))
    | "*" (not "=")
    | "/" (not "=")
    | "^" (not "=")
    | "&" (not ("=" | "&"))
    | "|" (not ("=" | "|"))
    | ">>" (not "=")
    | "<<" (not "=")
    | "+=" | "-=" | "*=" | "/=" | "^="
    | "&=" | "|=" | ">>=" | "<<="
    | "@"
    | "." (not ".")
    | ".." (not ".")
    | "..." | "," | ";"
    | ":" (not ":")
    | "::" | "->" | "<-" | "=>" | "#"
    | "$" | "?"
    | "(" | ")" | "{" | "}" | "[" | "]"
    | Underscore
\end{lstlisting}

\begin{itemize}
  \item 記号のパース規則は単純です。記号の候補の中で、一番長いものを選択します。
  \item アンダースコアだけ特殊です。アンダースコアは字句的には識別子に近いですが、パーサーに渡す段階では識別子よりも記号に近い扱いを受けます。
\end{itemize}

\subsection{リテラル}

\begin{lstlisting}[language=BNFLike, gobble=2]
  Literal ::= LiteralBody LiteralSuffix?

  LiteralBody ::= NumberLiteralBody | StringLikeLiteralBody

  LiteralSuffix ::= IdentifierOrKeyword | Underscore
\end{lstlisting}

\begin{itemize}
  \item リテラルは、数値リテラルと、文字列系リテラルの2種類あります。
  \item いずれのリテラルにも、識別子またはキーワードを後置することができます。これは型を表すのに使います。
  \item 識別子またはキーワードのかわりにアンダースコアを後置することもできます。リテラルの構造上数値リテラルでは不可能です。後置しても、パーサーからはなかったものとして扱われます。もしかしたらバグかもしれません。
  \item 後置された文字列は型として解釈されますが、これは構文解析器の仕事です。
\end{itemize}

\subsection{数値リテラル}

\begin{lstlisting}[language=BNFLike, gobble=2]
  NumberLiteralBody ::= IntegerLiteralBody | FloatLiteralBody

  IntegerLiteralBody ::=
      "0b" "_"* BinDigit BinDigitU* (not DecDigitU) EnsureNotFloat
    | "0o" "_"* OctDigit OctDigitU* (not DecDigitU) EnsureNotFloat
    | Decimal (not DecDigitU) EnsureNotFloat
    | "0x" "_"* HexDigit HexDigitU* (not HexDigitU) EnsureNotFloat

  EnsureNotFloat ::= not ("." | "e" | "E")
                   | lookahead ".."
                   | lookahead ("." IdentStart)

  FloatLiteralBody ::=
      Decimal "." (not ("." | IdentStart | DecDigit))
    | Decimal "." Decimal (not ("e" | "E"))
    | Decimal "." Decimal ExponentPart
    | Decimal ExponentPart

  ExponentPart ::=
      ("e" | "E") ("-" | "+")?
      "_"* DecDigit DecDigitU* (not DecDigitU)

  Decimal ::= DecDigit DecDigitU*

  BinDigit ::= "0" | "1"

  OctDigit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7"

  DecDigit ::= OctDigit | "8" | "9"

  HexDigit ::=
      DecDigit | "A" | "B" | "C" | "D" | "E" | "F"
    | "a" | "b" | "c" | "d" | "e" | "f"

  BinDigitU ::= BinDigit | "_"

  OctDigitU ::= OctDigit | "_"

  DecDigitU ::= DecDigit | "_"

  HexDigitU ::= HexDigit | "_"
\end{lstlisting}

\begin{itemize}
  \item 数値リテラルは、整数リテラルと浮動小数点数リテラルからなります。
  \item 負の符号は単なる単項演算子です。トークンとしては、非負の数のみ扱われます。
  \item アンダースコアで数を区切ることができます。しかし、数字がないのにアンダースコアだけある、という状況は禁止されています。また、リテラルの先頭や、小数点の直後には、アンダースコアを置くことはできません。
  \item 2進数、8進数、16進数では接頭辞を明示する必要があります。 \verb|0| で始まっていても10進数です。また、接頭辞は小文字でなければなりません。16進数の桁や、指数部をあらわす \verb|e| は大文字でも小文字でも構いません。
  \item 小数点の手前を省略することはできません。また、小数点の直後を省略できるのは、直後が \verb|.| でも識別子でもない場合だけです。
  \item 整数の直後に \verb|.| を置けるのは、その直後が \verb|.| または識別子の場合だけです。
  \item 上記の規則について、現在は \verb|._| が特別扱いされています。おそらくバグではないかと思います。
  \item また、現在は \verb|0e|, \verb|0E| から始まる浮動小数点数がパースエラーになるバグがあります。これは修正済みで、次の安定板には入ると思います。
  \item \verb|a| から \verb|f| までの文字は、16進数以外では、トークン区切りとみなされます。しかし、たとえ8進数であっても、 \verb|9| はトークン区切りとはみなされません。この位置でパースエラーになります。
  \item \verb|f| という文字は、微妙なバランスの上に成立しています。16進数は整数でしか使えないので、接尾辞には \verb|i| か \verb|u| が指定できれば十分です。いっぽう、 \verb|f| を含む接尾辞が指定される浮動小数点数では、 \verb|f| の部分でリテラル本体のパースが打ち切られるため、うまく \verb|f| を指定することができます。
\end{itemize}

\subsection{文字列系リテラル}

\begin{lstlisting}[language=BNFLike, gobble=2]
  StringLikeLiteralBody ::=
      ByteLiteralBody | ByteStringLiteralBody
    | CharLiteralBody | CharStringLiteralBody

  ByteLiteralBody ::=
      "b\'" (not ("\\" | "\t" | "\n" | "\r" | "\'")) AnyAsciiChar "\'"
    | "b\'\\" ("n" | "r" | "t" | "\\" | "\'" | "\"" | "0") "\'"
    | "b\'\\x" HexDigit HexDigit "\'"

  ByteStringLiteralBody ::=
      "b\"" SingleByte* "\""
    | "br" repeated("#", N) "\""
        ((not ("\"" repeated("#", N))) AnyAsciiChar)*
        "\"" repeated("#", N)
        /* N >= 0 */
        /* repeated("#", 3) means e.g. "###" */

  SingleByte ::=
      (not ("\\" | "\r" | "\"")) AnyAsciiChar
    | "\r\n"
    | "\\" ("n" | "r" | "t" | "\\" | "\'" | "\"" | "0")
    | "\\" ("\r\n" | "\n") Whitespace
    | "\\x" HexDigit HexDigit

  CharLiteralBody ::=
      "\'" (not ("\\" | "\t" | "\n" | "\r" | "\'")) AnyChar "\'"
    | "\'\\" ("n" | "r" | "t" | "\\" | "\'" | "\"" | "0") "\'"
    | "\'\\x" OctDigit HexDigit "\'"
    | "\'\\u{" HexDigit{1, 6} "}\'"
      /* only when x < 0xD800 or 0xE000 < x < 0x110000 */

  CharStringLiteralBody ::=
      "\"" SingleChar* "\""
    | "r" repeated("#", N) "\""
        ((not ("\"" repeated("#", N))) AnyChar)*
        "\"" repeated("#", N)
        /* N >= 0 */
        /* repeated("#", 3) means e.g. "###" */

  SingleChar ::=
      (not ("\\" | "\r" | "\"")) AnyChar
    | "\r\n"
    | "\\" ("n" | "r" | "t" | "\\" | "\'" | "\"" | "0")
    | "\\" ("\r\n" | "\n") Whitespace
    | "\\x" OctDigit HexDigit
    | "\\u{" HexDigit{1, 6} "}"
      /* only when x < 0xD800 or 0xE000 < x < 0x110000 */
\end{lstlisting}

\begin{itemize}
  \item バイト、バイト列、文字、文字列のいずれかを表します。
  \item バイトまたは文字は \verb|'| で囲み、バイト列または文字列は \verb|"| で囲みます。
  \item バイトまたはバイト列をあらわすときは \verb|b| を前置します。
  \item バイト列または文字列の場合は生リテラルを使うこともできます。生リテラルは \verb|"| のかわりに \verb|r###"| のような形で開始します。この場合最初に \verb|"###| が出現した位置で終了になります。 \verb|#| の個数は0個以上で、左右で揃える必要があります。
  \item バックスラッシュ、水平タブ、ラインフィード、キャリッジリターン、デリミタ(\verb|"| または \verb|'| のうちリテラルを囲うのに使われているほう) 以外のASCII文字は、そのまま書くことができます。
  \item ASCII以外のUnicode文字(Unicodeスカラー値)は、文字または文字列リテラルにそのまま書くことができます。
  \item タブ、ラインフィード、CRLF (キャリッジリターン+ラインフィード) は、生リテラルでないバイト列または文字列に直接書くことができます。CRLFはLFとみなされます。
  \item 生リテラル以外のリテラルでは、 \verb|\n|, \verb|\r|, \verb|\t|, \verb|\\|, \verb|\'|, \verb|\"|, \verb|\0| がエスケープとして利用できます。
  \item 生リテラル以外のリテラルでは、 \verb|\x| に続けて16進法で2桁(アンダースコア不可)の整数を指定することで、1バイトエスケープになります。ただし、 128より大きいバイトは、文字または文字列リテラルでは指定できません。
  \item 生リテラル以外の文字または文字列リテラルでは、 \verb|\u{}| の中に16進法で1桁から6桁まで(アンダースコア不可)の整数を指定することで、Unicodeエスケープになります。ただし指定できるのはUnicodeスカラー値、つまり \verb|0| 以上 \verb|0xD800| 未満か、 \verb|0xE000| 以上 \verb|0x110000| 未満の整数のみです。
  \item 生リテラル以外のバイト列または文字列リテラルでは、バックスラッシュの直後に改行(LFまたはCRLF)を続けると、該当バックスラッシュから、連続する空白文字が全てスキップされます。
  \item 生リテラルではエスケープは使用できず、全ての文字がそのまま解釈されます。生バイト列リテラルでは、ASCII文字以外(128以上のスカラー値)は使用できません。
\end{itemize}

\subsection{識別子またはキーワード}

\begin{lstlisting}[language=BNFLike, gobble=2]
  Identifier ::=
    (not (StrictKeyword | ReservedKeyword)) IdentifierOrKeyword

  IdentifierOrKeyword ::=
    (not (Underscore | MaybeString))
    IdentStart IdentContinue* (not IdentContinue)

  IdentStart ::=
    /* Any Unicode scalar value with XID_Start */ | "_"

  IdentContinue ::=
    /* Any Unicode scalar value with XID_Continue */ | "_"

  Underscore ::= "_" (not IdentContinue)

  MaybeString ::= "r\"" | "r#" | "b\"" | "b\'" | "br\"" | "br#"

  StrictKeyword ::= StrictKeywordString (not IdentContinue)

  StrictKeywordString ::=
      "as" | "box" | "break" | "const" | "continue" | "crate"
    | "else" | "enum" | "extern" | "false" | "fn" | "for"
    | "if" | "impl" | "in" | "let" | "loop" | "match" | "mod"
    | "move" | "mut" | "pub" | "ref" | "return" | "self" | "Self"
    | "static" | "struct" | "super" | "trait" | "true" | "type"
    | "unsafe" | "use" | "where" | "while"

  ReservedKeyword ::= ReservedKeywordString (not IdentContinue)

  ReservedKeywordString ::=
      "abstract" | "alignof" | "become" | "do" | "final"
    | "macro" | "offsetof" | "override" | "priv" | "proc"
    | "pure" | "sizeof" | "typeof" | "unsized" | "virtual"
    | "yield"

  WeakKeyword ::= WeakKeywordString (not IdentContinue)

  WeakKeywordString ::= "default" | "union"
\end{lstlisting}

\begin{itemize}
  \item 識別子またはキーワードは、 ASCIIの数字、大文字、小文字、アンダースコアからなります。また最初の文字はASCIIの大文字、小文字、アンダースコアのいずれかでなければなりません。
  \item この規則は \verb|feature(non_ascii_idents)| によりUnicodeに拡張されます。この場合、識別子は \verb|XID_Continue| な文字またはアンダースコアからなります。また、最初の文字は \verb|XID_Start| な文字またはアンダースコアでなければなりません。これはUAX~\#31~\cite{UAX31-25}を考慮していますが、現在の実装は完全とはいえません。UAX~\#31ではNKFC等の正規化が言及されていますが、現在のコンパイラは正規化を全くしません。どの正規化をするかなどを含めて、議論の途中の状態です。
  \item アンダースコア1文字からなる場合は、識別子ではなく記号として解釈されます。
  \item \verb|r"|, \verb|r#|, \verb|b"|, \verb|b'|, \verb|br"|, \verb|br#| のいずれかで始まる場合は、これらの \verb|r|, \verb|b|, \verb|br| は識別子ではなく文字列系リテラルの開始として解釈されます。
  \item 「識別子またはキーワード」のうち、いくつかは「強キーワード (strict keyword)」「予約キーワード (reserved keyword)」「弱キーワード (weak keyword)」のいずれかに分類されています。強キーワードは特別な意味をもつもので、予約キーワードは将来強キーワードとして使われる可能性を考慮して予約されているものです。
  \item 強キーワードでも予約キーワードでもないものを識別子といいます。弱キーワードは、原則として識別子として扱われますが、文脈によっては特別な意味を持ちます。
  \item 識別子またはキーワードは、マクロの観点からはキーワードか否かに関係なく同等に扱われます。識別子またはキーワードと、生存期間には、構文文脈が付与されます。アンダースコアは識別子またはキーワードではないため、構文文脈は付与されません。
  \item 字句解析器は、空の構文文脈を付与します。
\end{itemize}

\subsection{生存期間}

\begin{lstlisting}[language=BNFLike, gobble=2]
  Lifetime ::=
      (not "\'" IdentStart "\'")
      "\'" IdentifierOrKeyword

  WeakLifetimeKeyword ::= "\'static" (not IdentContinue)
\end{lstlisting}

\begin{itemize}
  \item \verb|'| に識別子またはキーワードを後続させたものは、生存期間です。
  \item ただし、文字リテラルとしても解釈できる場合は、文字リテラルが優先されます。
  \item \verb|'_| は生存期間ではありません。
  \item \verb|'static| は生存期間ですが、文脈によっては特別な意味を持ちます。
  \item 識別子またはキーワードと、生存期間には、構文文脈が付与されます。
  \item 字句解析器は、空の構文文脈を付与します。
\end{itemize}

\subsection{特殊なトークン}

字句解析器以外によってのみ生成される特殊なトークンがいくつかあります。

\begin{itemize}
  \item 空文字列、 \verb|{{root}}|, \verb|$crate| はいずれも、上で説明した「識別子またはキーワード」の条件を満たしていませんが、内部的に識別子として生成される場合があります。
  \item 同じく、空文字列が内部的に生存期間として生成される場合があります。なお、通常の生存期間の名前は、内部的には \verb|'| を含んだ形で保存されています。
  \item 補間トークンは、ASTを1つのトークンとしてみなしたものです。
    \begin{itemize}
      \item アイテム、ブロック、文、パターン、式、型、識別子を含む補間トークンは、マクロの展開のために使われます。
      \item メタアイテム、パス、トークンツリーを含む補間トークンは、属性構文拡張の展開のために使われます。
      \item パターンマッチの腕、実装内アイテム、トレイト内アイテム、ジェネリックス、 \verb|where| 節、関数の仮引数部分は、準クオートの実現のために内部的に使用されます。
    \end{itemize}
  \item マクロの変数置換 \verb|$x| を表すためのトークン。内部的には \verb|$| を含まない形で保存されます。構文文脈も保存されます。
\end{itemize}

\section{構文解析}

Rustの構文解析器は、大まかにいうと次の2つの仕事を行います。

\begin{itemize}
  \item トークン列を抽象構文木に変換する。
  \item \verb|mod foo;| がある場合は、別のファイルを新規に読み出して再帰的に字句解析と構文解析を呼び出す。
\end{itemize}

後者は、C言語でいうところの \verb|#include| と似ていると考えてよいでしょう。ただし、Rustではプリプロセッサーではなく構文解析器がこれを行います。

\subsection{構文解析のための字句}

Rustのトークン列は、構文解析器から見ると大雑把に以下のように分類されます。

ここでは簡単のために、記号やキーワードなどのトークンは単に \verb|"*="| や \verb|"fn"| といった文字列として表記します。実際には単一のトークンにマッチすると考えてください。

\begin{lstlisting}[language=BNFLike, gobble=2]
  Token ::= NonParen | "(" | ")" | "{" | "}" | "[" | "]"

  NonParen ::=
      InnerDocComment
    | OuterDocComment
    | "=" | "<" | "<=" | "==" | "!=" | ">=" | ">"
    | "&&" | "||" | "!" | "~"
    | "+" | "-" | "*" | "/" | "^" | "&" | "|" | ">>" | "<<"
    | "+=" | "-=" | "*=" | "/=" | "^="
    | "&=" | "|=" | ">>=" | "<<="
    | "@" | "." | ".." | "..." | "," | ";" | ":"
    | "::" | "->" | "<-" | "=>" | "#" | "$" | "?"
    | "_"
    | IntegerLiteral | FloatLiteral
    | ByteLiteral | ByteStringLiteral
    | CharLiteral | CharStringLiteral
    | Identifier
    | Lifetime
    | "as" | "box" | "break" | "const" | "continue" | "crate"
    | "else" | "enum" | "extern" | "false" | "fn" | "for"
    | "if" | "impl" | "in" | "let" | "loop" | "match" | "mod"
    | "move" | "mut" | "pub" | "ref" | "return" | "self" | "Self"
    | "static" | "struct" | "super" | "trait" | "true" | "type"
    | "unsafe" | "use" | "where" | "while"
    | "" | "{{root}}" | "$crate"
    | NtItem | NtBlock | NtStmt | NtPat | NtExpr | NtTy | NtIdent
    | NtMeta | NtPath | NtTT
    | NtArm | NtImplItem | NtTraitItem | NtGenerics
    | NtWhereClause | NtArg
    | SubstNt
\end{lstlisting}

\begin{itemize}
  \item 記号や強キーワードはそれぞれ別種のトークンとして扱われます。
  \item 弱キーワード \verb|default|, \verb|union|, \verb|'static| は原則として識別子や生存期間の一種として扱われますが、特定の文脈では特別扱いされます。
  \item リテラルの種類は構文解析にとってはそれほど重要ではありませんが、整数リテラルと文字列リテラルは特別な扱いを受けることがあります。
\end{itemize}

\subsection{列の文法}

Rustの構文では、コンマ区切りの列が様々な場所で出てきます。これらの多くは、0個以上の要素が指定可能で、末尾に最大1個の余分なコンマをつけることが許されています。

この節では、このパターンを、以下のように定義される \verb|sequence(E, D)| を用いて略記します。

\begin{lstlisting}[language=BNFLike, gobble=2]
  sequence(E, D) ::= (E (D E)* D?)?
\end{lstlisting}

\subsection{crate}

\begin{lstlisting}[language=BNFLike, gobble=2]
  Crate ::= InnerAttribute* Item*
\end{lstlisting}

\begin{itemize}
  \item crate全体はmodとほぼ同じですが、構造上外部属性が指定できません。
\end{itemize}

\subsection{アイテム}

\begin{lstlisting}[language=BNFLike, gobble=2]
  Item ::= OuterAttribute* (NtItem | Visibility? ItemBody)

  ItemBody ::=
      ItemExternCrate
    | ItemUse
    | ItemStatic
    | ItemConst
    | ItemFn
    | ItemMod
    | ItemForeign
    | ItemType
    | ItemEnum
    | ItemStruct
    | ItemUnion
    | ItemTrait
    | ItemImpl
    | ItemMacro
\end{lstlisting}

\begin{itemize}
  \item 関数や型など、Rustでグローバルな位置に置けるものはアイテムと呼ばれます。
  \item アイテムには属性と可視性を付与することができます。内部属性を書けるアイテムについては、内部属性と外部属性はマージされます。
  \item 構文解析済みのトークン (NtItem) が来た場合はそれをそのまま受理します。 NtItemには可視性を付与することはできません。 NtItem に由来する属性と、 NtItem に付与した外部属性は、マージされます。
  \item \verb|unsafe| や \verb|extern| などのキーワードを前置できるアイテムがあるため、アイテムの種類を決定するには数トークンほど先読みをする必要があります。
\end{itemize}

\subsection{外部crate宣言}

\begin{lstlisting}[language=BNFLike, gobble=2]
  ItemExternCrate ::=
    "extern" "crate" Identifier ("as" Identifier)? ";"
\end{lstlisting}

\begin{itemize}
  \item crateのルートモジュールを \verb|as| で指定した名前で参照します。
  \item \verb|as| を省略した場合は、crate名が使われます。
\end{itemize}

\subsection{インポート}

\begin{lstlisting}[language=BNFLike, gobble=2]
  ItemUse ::=
      "use" ModPath ("as" Identifier)? ";"
    | "use" ModPath? "::" "*" ";"
    | "use" (ModPath? "::")? "{" sequence(UseListElement, ",") "}" ";"

  UseListElement ::= (Identifier | "self") ("as" Identifier)?
\end{lstlisting}

\begin{itemize}
  \item 定義に対する別名づけを行います。単独インポートとグロブインポートの2種類があります。
  \item \verb|{| \verb|}| で囲んだものはリストインポートといい、複数の単独インポートに展開されます。 \verb|self| を使うことで、モジュールそのものとモジュール内の定義を同時にインポートすることもできます。
  \item 単独インポートで \verb|as| を省略した場合は、パスの最後の要素が採用されます。
  \item パスが通常の識別子から始まる場合は、強制的に絶対パスとして解釈されます。
\end{itemize}

\subsection{静的アイテムと定数アイテム}

\begin{lstlisting}[language=BNFLike, gobble=2]
  ItemStatic ::= "static" "mut"? Identifier ":" Type "=" Expression ";"

  ItemConst ::= "const" Identifier ":" Type "=" Expression ";"
\end{lstlisting}

\begin{itemize}
  \item 定数または静的記憶期間を持つ領域を定義します。定数に \verb|mut| はつけられません。
  \item \verb|let| とは異なり、型は必須です。また、 \verb|let| のように左辺にパターンは使えません。
\end{itemize}

\subsection{関数定義}

\begin{lstlisting}[language=BNFLike, gobble=2]
  ItemFn ::=
    ItemFnPrefix "fn" Identifier Generics?
    "(" sequence(Pattern ":" Type, ",") ")" ("->" Type)?
    WhereClauses?
    Block

  ItemFnPrefix ::=
      "unsafe"? ("extern" CharStringLiteral?)?
    | "const" "unsafe"?
\end{lstlisting}

\begin{itemize}
  \item 関数を定義します。
  \item \verb|feature(const_fn)| により \verb|const| が指定できます。指定すると、定数文脈でその関数を利用できるようになります。
  \item \verb|unsafe| を指定すると、この関数の利用はunsafeだとマークされます。同時に、関数内部ではunsafe機能の利用が可能になります。
  \item \verb|extern| によりABIを指定できます。 \verb|extern| を省略すると \verb|"rust"| ABIになります。 \verb|extern| とだけ指定すると \verb|"C"| ABIになります。
  \item \verb|const| と \verb|extern| は同時指定できません。
  \item ジェネリックスおよび \verb|where| が指定できます。ジェネリックスの位置は関数名の直後で、 \verb|where| の位置は戻り値型の直後です。
  \item 引数リストはパターンと型を並べたものです。他の \verb|fn| に比べて最も単純といえます。
  \item ブロック内に内部属性があれば、それは関数の属性になります。
\end{itemize}

\subsection{モジュール}

\begin{lstlisting}[language=BNFLike, gobble=2]
  ItemMod ::=
      "mod" Identifier ";"  /* Parser treats it specially. */
    | "mod" Identifier "{" InnerAttribute* Item* "}"

  ModuleFile ::= InnerAttribute* Item*
\end{lstlisting}

\begin{itemize}
  \item \verb|mod foo {}| はモジュールを定義します。中には内部属性とアイテムを書くことができます。
  \item \verb|mod foo;| のようにセミコロン終端された \verb|mod| は、それ自身はモジュールの中身を持っていません。そこで、構文解析器はその場で別のファイルを開いて、そこからモジュールの中身を読み取ります。
  \item \verb|mod foo;| の処理は、このアイテムに付属している外部属性に影響を受けます。ファイルを発見するまでは内部属性は入手できませんから、ファイル発見にかかわる設定は外部属性として書かなければいけません。
  \item 通常、属性の内容は構文解析より後に処理されますが、 \verb|mod| に付与された \verb|cfg_attr(...)| はその場で処理されます。(\verb|mod foo {}| でも処理されますが、これが仕様かどうかはわかりません。)
  \item さらに、 \verb|mod foo;| 形式の場合は、 \verb|cfg(...)| がその場で処理されます。偽と評価された場合はファイルの探索を行いません。 (\verb|mod foo {}| では処理されませんが、これが仕様かどうかはわかりません。)
  \item \verb|mod foo;| のファイル発見規則はやや複雑です。まず、ローカルcrateの各モジュールにはディレクトリが紐付けられています。また、そのモジュールがディレクトリを「所有しているかどうか」というフラグも管理されています。これに基いて以下のようにファイルが発見されます。
    \begin{itemize}
      \item crateのルートモジュールのファイルとディレクトリは、コンパイラドライバによって指定される。例えば \verb|src/main.rs| と \verb|src| / 所有 が指定される。
      \item \verb|mod foo {}| は親モジュールのディレクトリの直下の \verb|foo| が紐付けられる。所有関係は親モジュールから継承される。
      \item ただし、 \verb|#[path = "somewhere"]| (ディレクトリ) が指定された場合は、親モジュールからの相対パスでこのディレクトリが紐付けられ、このディレクトリを所有していることになる。
      \item ブロックには、それを含むモジュールと同じディレクトリが紐付けられるが、そのディレクトリを所有はしない。
      \item \verb|mod foo;| はまずファイルを探索する。親モジュールのディレクトリの直下の \verb|foo.rs| と \verb|foo/mod.rs| のうち、存在しているほうを採用する。どちらもなかったり、どちらも存在している場合はエラーとなる。また、親モジュールがディレクトリを所有していない場合はエラーとなる。
      \item ただし、 \verb|#[path = "somewhere"]| (ファイル) が指定された場合は、上記のファイルを探索せずに、指定されたファイルを採用する。親モジュールがディレクトリを所有していなくてもエラーとはならない。
      \item 採用されたファイルの直上のディレクトリが紐付けられる。ファイル名が \verb|mod.rs| だった場合のみ、所有しているものとみなされる。
      \item マクロ呼び出しの実引数がパースされるさいは、マクロ呼び出しの位置でパースされたかのように振る舞う。マクロ展開結果がパースされるさいも、マクロ呼び出しの位置でパースされたかのように振る舞う。
    \end{itemize}
\end{itemize}

\subsection{外部アイテムの参照}

\begin{lstlisting}[language=BNFLike, gobble=2]
  ItemForeign ::=
    "extern" CharStringLiteral?
    "{" InnerAttribute* ForeignItem* "}"

  ForeignItem ::=
    OuterAttribute* Visibility?
    (ForeignItemStatic | ForeignItemFn)

  ForeignItemStatic ::=
    "static" "mut"? Identifier ":" Type ";"

  ForeignItemFn ::=
    "fn" Identifier Generics?
    ForeignItemFnArgs ("->" Type)?
    WhereClauses? ";"

  ForeignItemFnArgs ::=
      "(" sequence(Pattern ":" Type, ",") ")"
    | "(" (Pattern ":" Type ",")+ "..." ")"
\end{lstlisting}

\begin{itemize}
  \item 外部で定義されたシンボルをアイテムとして参照するには \verb|extern { }| で囲みます。ABI名を省略した場合は \verb|"C"| として扱われます。
  \item 静的変数や関数の定義と似ていますが、定義部分がありません。
  \item \verb|fn| に \verb|const|, \verb|unsafe|, \verb|extern| などを追加で指定することはできません。
  \item 個別のアイテムに可視性をつけることができます。なお、 \verb|extern| 自身に可視性をつけても構文解析後にエラーになります。
  \item 関数定義と同様、引数名は必要です。引数はパターンとしてパースされますが、識別子とワイルドカード以外のパターンを指定すると構文解析後にエラーになります。
  \item 引数リストの末尾に \verb|...| を指定することで可変長引数を表現できます。可変長部分の前に1つ以上の引数が必要です。
\end{itemize}

\subsection{型別名}

\begin{lstlisting}[language=BNFLike, gobble=2]
  ItemType ::= ...
\end{lstlisting}

\subsection{列挙型}

\begin{lstlisting}[language=BNFLike, gobble=2]
  ItemEnum ::= ...
\end{lstlisting}

\subsection{構造体}

\begin{lstlisting}[language=BNFLike, gobble=2]
  ItemStruct ::= ...
\end{lstlisting}

\subsection{共用体}

\begin{lstlisting}[language=BNFLike, gobble=2]
  ItemUnion ::= ...
\end{lstlisting}

\subsection{トレイト}

\begin{lstlisting}[language=BNFLike, gobble=2]
  ItemTrait ::= ...
\end{lstlisting}

\subsection{実装}

\begin{lstlisting}[language=BNFLike, gobble=2]
  ItemImpl ::= ...
\end{lstlisting}

\subsection{型}

\begin{lstlisting}[language=BNFLike, gobble=2]
  Type ::= ...
\end{lstlisting}

\subsection{式}

\begin{lstlisting}[language=BNFLike, gobble=2]
  Expression ::= ...
\end{lstlisting}

\subsection{パターン}

\begin{lstlisting}[language=BNFLike, gobble=2]
  Pattern ::= ...
\end{lstlisting}

\subsection{ブロック}

\begin{lstlisting}[language=BNFLike, gobble=2]
  Block ::= ...
\end{lstlisting}

\subsection{文}

\begin{lstlisting}[language=BNFLike, gobble=2]
  Statement ::= ...
\end{lstlisting}

\subsection{ジェネリックス}

\begin{lstlisting}[language=BNFLike, gobble=2]
  Generics ::= ...
\end{lstlisting}

\subsection{where節}

\begin{lstlisting}[language=BNFLike, gobble=2]
  WhereClauses ::= ...
\end{lstlisting}

\subsection{マクロ呼び出し}

\begin{lstlisting}[language=BNFLike, gobble=2]
  ItemMacro ::= ...
\end{lstlisting}

\subsection{パス}

\begin{lstlisting}[language=BNFLike, gobble=2]
  ModPath ::= ...
\end{lstlisting}

\subsection{可視性}

\begin{lstlisting}[language=BNFLike, gobble=2]
  Visibility ::= ...
\end{lstlisting}

\subsection{属性}

\begin{lstlisting}[language=BNFLike, gobble=2]
  OuterAttribute ::= ...

  InnerAttribute ::= ...
\end{lstlisting}



\chapter{構文拡張}

\section{構文拡張のデータベース}

\section{マクロ}

\section{組み込みマクロ}

\section{macro\_rules}

\section{属性構文拡張}

\section{手続きマクロ}



\chapter{名前解決}

\section{モジュール}

\section{インポート解決}

\section{レキシカルスコープの解決}

\section{型依存の名前解決}

\section{生存期間の解決}



\chapter{型検査}

\section{型}

\section{トレイト}

\section{Hindley-Milner型推論}

\section{トレイト選択}

\section{リージョン推論}

\section{ドロップ検査}

\section{借用検査}

\section{可変性検査}



\chapter{コード生成}

\section{MIR}

\section{LLVM IR}



\chapter{ドキュメンテーション}

\section{doc-commentの構文}



\bibliographystyle{plain}
\bibliography{refs}

\end{document}

